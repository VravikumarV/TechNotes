
Must Follow (Do's and DoNts):
*************************************

-------------------------------------
[Warning] Warning: componentWillMount has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details. (0.chunk.js, line 131513)

https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.

Please update the following components: UserProfile
-------------------------------------
https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html



[Error] Warning: Can't call setState on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the UserProfile component.
	printWarning (0.chunk.js:161190)
	error (0.chunk.js:161162)
	warnNoop (0.chunk.js:161217)
	enqueueSetState (0.chunk.js:161287)
	(anonymous function) (0.chunk.js:161342)
	(anonymous function) (main.chunk.js:469)
	promiseReactionJob
-------------------------------------

https://stackoverflow.com/questions/36897434/error-handling-in-react-best-practices/54573375

1. Error boundries [ From react 16 ] (componentDidCatch):
         A class component becomes an error boundary if it defines either (or both) of the lifecycle methods static getDerivedStateFromError() or componentDidCatch(). Use static getDerivedStateFromError() to render a fallback UI after an error has been thrown. Use componentDidCatch() to log error information.
	 
	Error boundaries work like a JavaScript catch {} block, but for components. Only class components can be error boundaries. In practice, most of the time you’ll want to declare an error boundary component once and use it throughout your application.

			Event handlers (learn more)
			Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)
			Server side rendering
			Errors thrown in the error boundary itself (rather than its children)
2. Try catch		[only works for imperative code:]
3. 

-------------------------------------

https://reactjs.org/blog/2020/10/20/react-v17.html [ V Imp ]
UPdating the whole app at once from 15 to 16 or 16 to 17

----------------------------------------

https://relay.dev

Relay: [Built for scale] Relay is designed for high performance at any scale. Relay keeps management of data-fetching easy, whether your app has tens, hundreds, or thousands of components. And thanks to Relay’s incremental compiler, it keeps your iteration speed fast even as your app grows.


The GraphQL client that scales with you.

Keeps Intercations quick:

Relay is data-fetching turned declarative. Components declare their data dependencies, without worrying about how to fetch them. Relay guarantees that the data each component needs is fetched and available. This keeps components decoupled and promotes reuse.

With Relay, components and their data dependencies can be quickly modified without modifying other parts of the system. That means you won't accidentally break other components as you refactor or make changes to your app.

Automatic Optimisations:

Relay's compiler aggregates and optimizes the data requirements for your entire app, so that they can be efficiently fetched in a single GraphQL request.

Relay handles the heavy lifting to ensure the data declared by your components is fetched in the most efficient way. For example, by deduplicating identical fields, and precomputing information used at runtime, among other optimizations.

Data Consistency:
Relay automatically keeps all of your components up to date when data that affects them changes, and efficiently updates them only when strictly necessary. This means no unnecessary re-renders.

Relay also supports executing GraphQL Mutations, optionally with optimistic updates, and updates to local data, while ensuring that visible data on the screen is always kept up to date.

The simplest way to fetch query data is to directly call loadQuery.

Later, you can read the data from the store in a functional React component by calling the usePreloadedQuery hook.

Relay encourages you to call loadQuery in response to an event, such as when a user presses on a link to navigate to a particular page or presses a button. See the guided tour section on Queries for more.

import {
  EnvironmentProvider,
  loadQuery,
  graphql,
  usePreloadedQuery,
} from "react-relay";

-----------------------------------------------
client side vs server side rewndering:


https://stackoverflow.com/questions/27290354/reactjs-server-side-rendering-vs-client-side-rendering

https://www.digitalocean.com/community/tutorials/react-server-side-rendering

https://www.freecodecamp.org/news/server-side-rendering-your-react-app-in-three-simple-steps-7a82b95db82e/

https://www.newline.co/fullstack-react/p/components-servers/
-----------------------------------------------
Memory leaks, Optimisation, Responsiveness, latency :

https://dev.to/nans/an-elegant-solution-for-memory-leaks-in-react-1hol

https://www.freecodecamp.org/news/how-to-work-with-react-the-right-way-to-avoid-some-common-pitfalls-fc9eb5e34d9e/

https://stackoverflow.com/questions/59780268/cleanup-memory-leaks-on-an-unmounted-component-in-react-hooks

https://reactjs.org/docs/optimizing-performance.html

https://medium.com/technofunnel/https-medium-com-mayank-gupta-6-88-21-performance-optimizations-techniques-for-react-d15fa52c2349

https://www.codementor.io/blog/react-optimization-5wiwjnf9hj

https://www.toptal.com/react/optimizing-react-performance

https://blog.bitsrc.io/improve-react-performance-using-lazy-loading-and-suspense-933903171954 [ Lazy load & suspence - To improve performance ]
https://www.infoq.com/articles/reduce-react-load-time/
https://www.smashingmagazine.com/2020/07/methods-performance-react-apps/
https://www.simform.com/react-native-app-performance/
https://www.simform.com/react-performance/


https://www.sitepoint.com/react-architecture-best-practices/


--------------------------------------------------

Redux vs MobX vs




https://medium.com/@mustwin/responsive-react-9b56d63c4edc
https://codeburst.io/how-to-build-fully-responsive-react-apps-with-nothing-but-inline-styles-and-javascript-242c091b6ba1
https://dev.to/flexdinesh/introducing-responsive-react-components--1a6a
https://www.telerik.com/blogs/creating-a-responsive-layout-in-react



-----------------------------------------------
Responsive application design:

1. How do you design and implemenet resuble components ? 
2. How do you makem your components resuable across teams, projects and repositotires ? [ Bit ]


codemod: 

cd your_project
npx react-codemod rename-unsafe-lifecycles


Buzz words: Lint, Babel, Flex box (CSS), codemod, 

Bit: Bit is an open-source cli tool for collaborating on isolated components across projects and repositories.
Use Bit to distribute discrete components from a design library or a project into a standalone reusable package and utilize it across applications.
You can set up your own server for components collaboration, or use the bit.dev cloud hosting for private and public components sharing.
https://github.com/teambit/bit


https://blog.bitsrc.io/introducing-layout-for-material-ui-329043618cb3
https://www.robinwieruch.de/react-pass-props-to-component

React:


Mixins, Suspense, Subcriptions, Promise

Render Props:  https://reactjs.org/docs/render-props.html
The term “render prop” refers to a technique for sharing code between React components using a prop whose value is a function.
A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic.

<DataProvider render={data => (
  <h1>Hello {data.target}</h1>
)}/>
Libraries that use render props include React Router, Downshift and Formik.
In this document, we’ll discuss why render props are useful, and how to write your own.
Use Render Props for Cross-Cutting Concerns
Be careful when using Render Props with React.PureComponent

A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React’s compositional nature.
https://reactjs.org/docs/higher-order-components.html
Concretely, a higher-order component is a function that takes a component and returns a new component.
const EnhancedComponent = higherOrderComponent(WrappedComponent);


Rules for Hooks:

We finally can use state in React Functions and get away from “Wrapper Hell”. That’s the power of the new feature — React Hooks.

Hooks are JavaScript functions, but they impose two additional rules:
Only call Hooks at the top level. Don’t call Hooks inside loops, conditions, or nested functions.
Only call Hooks from React function components. Don’t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks — your own custom Hooks. We’ll learn about them in a moment.)
We provide a linter plugin to enforce these rules automatically. We understand these rules might seem limiting or confusing at first, but they are essential to making Hooks work well.


The state of each component is completely independent. Hooks are a way to reuse stateful logic, not state itself. In fact, each call to a Hook has a completely isolated state — so you can even use the same custom Hook twice in one component.


Render Prop vs HOC ?
React.Component vs React.PureComponent
React class components vs functional components:   https://medium.com/@Zwenza/functional-vs-class-components-in-react-231e3fbd7108
https://github.com/acdlite/recompose



     Function Components vs class:
     Highorder components:
      PureComponent:

     Controlled Components:         In React, mutable state is typically kept in the state property of components, and only updated with setState().
     Fully Controlled Components:
     UnCOntrolled Components:
     React.Component:
     React.PureComponent:
     React.Fragment:                React also provides a component for rendering multiple elements without a wrapper.
     React.Suspense:                Suspense lets components “wait” for something before rendering. Today, Suspense only supports one use case: loading components dynamically with React.lazy. In the future, it will support other use cases like data fetching.
     React.Lazy:                    React.lazy() lets you define a component that is loaded dynamically. This helps reduce the bundle size to delay loading components that aren’t used during the initial render.
                              const SomeComponent = React.lazy(() => import('./SomeComponent'));
                              Note that rendering lazy components requires that there’s a <React.Suspense> component higher in the rendering tree. This is how you specify a loading indicator.
                              Note
                              Using React.lazywith dynamic import requires Promises to be available in the JS environment. This requires a polyfill on IE11 and below.

                              Note:
                                          React.lazy() and <React.Suspense> are not yet supported by ReactDOMServer. This is a known limitation that will be resolved in the future.

     React.createRef:
     React.forwardRef:
     React.memo:                     
     Promises:    
                  Mounting:
                  
                         constructor()                                          (1)
                         static getDerivedStateFromProps()                      (2)
                         render()                                               (3)
                         componentDidMount()                                    (4)
                        
                  Update:
                  
                          static getDerivedStateFromProps(props, state):         (1)
                                        Is invoked right before calling the render method, both on the initial mount and on subsequent updates.
                                        It should return an object to update the state, or null to update nothing.
                              
                                        Deriving state leads to verbose code and makes your components difficult to think about.
                                        Make sure you’re familiar with simpler alternatives:
                                        If you need to perform a side effect (for example, data fetching or an animation) in response to a change in props, use componentDidUpdate lifecycle instead.
                                        If you want to re-compute some data only when a prop changes, use a memoization helper instead.
                                        If you want to “reset” some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a key instead.

                         shouldComponentUpdate(nextProps, nextState):           (2)
                                          Instead of shouldComponentUpdate, consider using the built-in PureComponent instead of writing shouldComponentUpdate() by hand. PureComponent performs a shallow comparison of props and state, and reduces the chance that you’ll skip a necessary update.
                                          If you are confident you want to write it by hand, you may compare this.props with nextProps and this.state with nextState and return false to tell React the update can be skipped. Note that returning false does not prevent child components from re-rendering when their state changes.
                                          We do not recommend doing deep equality checks or using JSON.stringify() in shouldComponentUpdate(). It is very inefficient and will harm performance

                         render()
                         getSnapshotBeforeUpdate()
                         componentDidUpdate()


                  UnMounting:
                  
                  


                  Error boundaries:       Error boundaries only catch errors in the components below them in the tree. An error boundary can’t catch an error within itself.

                        Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.
                        A class component becomes an error boundary if it defines either (or both) of the lifecycle methods static getDerivedStateFromError() or componentDidCatch(). Updating state from these lifecycles lets you capture an unhandled JavaScript error in the below tree and display a fallback UI.

                  static getDerivedStateFromError(error):
                  componentDidCatch(error, info):
                  

Lify cycle:

      https://reactjs.org/docs/state-and-lifecycle.html

      https://programmingwithmosh.com/javascript/react-lifecycle-methods/

      Every component in React goes through a lifecycle of events. I like to think of them as going through a cycle of birth, growth, and death.

      Mounting – Birth of your component
      Update – Growth of your component
      Unmount – Death of your component
      Now that we understand the series of lifecycle events let’s learn more about how they work.

      https://programmingwithmosh.com/javascript/react-lifecycle-methods/
      ES6:     https://medium.com/the-andela-way/a-beginners-guide-to-react-with-es6-a2ed0b5c977e
      Basics:  https://medium.com/the-andela-way/understanding-the-fundamentals-of-state-in-react-79c711be677f
      
      Routers:
      
                    https://reactrouter.com/native/guides/quick-start
                    https://medium.com/the-andela-way/understanding-the-fundamentals-of-routing-in-react-b29f806b157e
      
                    react-router:            A core library
                    react-router-dom:        A variant of core library meant to be used for we applications
                    react-router-native:     A variant of the core library used with react native in the development of Android and iOS applications.
      
                    npm install --save react-router-dom
                    
                    There are number of routers available each corresponds to a particular platform. Those include the following...
                                             BrowserRouter:      Dynamic (server based applications)
                                             HashRouter:         Static web sites
                                             MemoryRouter:       
                    Worth noting is that any router expects to receive only one child.
                    
                         ReactDOM.render(
                                          <BrowserRouter>
                                            <App/>
                                          </BrowserRouter>,
                                          document.getElementById(‘root’));     -- BrowserRouter should have only one child, in this case its <App/> component.
                     
                    
                    History:                 Each router creates a history objects which it uses to old the location and re-renders the appliction when the location changes.
                    
                                        <Route path="/items" />
                                        <Route exact path="/items" />
                                        
                                        Route is having 3 props which decides which needs to be frendered.
                                        1. Component:       <Route exact path=”/items” component={Items} />
                                        2. render:          <Route exact path=”/items” render = {() => (<div>List of Items</div>)}  />
                                        3. Children:        <Route children={props => <Items {…props}/>}/>
                   Switch:               
                                        <Switch>
                                          <Route 
                                            path=”/items” 
                                            render={() => (<div><em>List of items</em></div>)}
                                          />
                                          <Route 
                                            path=”/items/2" 
                                            render={() => (<div>Item with id of 2</div>)}
                                          />
                                        </Switch>
                    Link:          <Link/> It is similar to HTML’s anchor element but the main difference is that using the Link component does not reload the page but rather, changes the UI. 
                    
                    
                                                            export const Home = () => (
                                                                                  <div>
                                                                                    Home Component
                                                                                    <ul>
                                                                                      <li>
                                                                                        <Link to=”/items”>Items</Link>
                                                                                      </li>
                                                                                      <li>
                                                                                        <Link to=”/category”>Category</Link>
                                                                                       </li>
                                                                                    </ul>
                                                                                  </div>
                                                                                );
                                                                                
                    Nested Routing:     
                    
                    Protected Routes:
                    
                    Custom Routes:

                    
      React Before Hooks vs Afetr Hooks:
      
      Hooks:             Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class. Hooks have a dedicated 
      docs section and a separate API reference:

          https://www.telerik.com/kendo-react-ui/react-hooks-guide/
          
               Hooks don’t replace your knowledge of React concepts. 
               Instead, Hooks provide a more direct API to the React concepts you already know: props, state, context, refs, and lifecycle.
               As we will show later, Hooks also offer a new powerful way to combine them.


             Basic Hooks:
                        useState
                        useEffect
                        useContext:       const value = useContext(MyContext);
                        
                                Accepts a context object (the value returned from React.createContext) and returns the current context value for that context. The current context value is determined by the value prop of the nearest <MyContext.Provider> above the calling component in the tree.
                                When the nearest <MyContext.Provider> above the component updates, this Hook will trigger a rerender with the latest context value passed to that MyContext provider. Even if an ancestor uses React.memo or shouldComponentUpdate, a rerender will still happen starting at the component itself using useContext.

                        
            Additional Hooks:
                        useReducer:      const [state, dispatch] = useReducer(reducer, initialArg, init);
                        An alternative to useState. Accepts a reducer of type (state, action) => newState, and returns the current state paired with a dispatch method. (If you’re familiar with Redux, you already know how this works.)
                        useReducer is usually preferable to useState when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. useReducer also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks.

                        useCallback:    useCallback(fn, deps)
                        useMemo:        useMemo(() => fn, deps)
                                        const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

                        useRef:         const refContainer = useRef(initialValue);
                                        useRef returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component.
                                        Essentially, useRef is like a “box” that can hold a mutable value in its .current property.
  
                       
                        useImperativeHandle:      useImperativeHandle(ref, createHandle, [deps])
                                        
                        useLayoutEffect
                        useDebugValue
                        
                        useHistory      (react-router-dom)
                        
            Hooks from react-redux:
                        useDispatch     
                        useSelector

      
      Redux & Redux Alternatives:
                              https://redux.js.org/introduction/motivation
                              https://redux.js.org/introduction/getting-started
                              https://redux.js.org/introduction/three-principles
                              https://react-redux.js.org/using-react-redux/connect-mapdispatch                   
                              https://react-redux.js.org/using-react-redux/connect-mapstate    (V.Good & V.Imp)
                              https://immerjs.github.io/immer/docs/pitfalls
                              
      Redux:         A predictable state container for JavaScript applications   
      
                npm install @reduxjs/toolkit
                npm install redux
                
                npx create-react-app my-app --template redux
                
                Redux is more useful when:

                              You have large amounts of application state that are needed in many places in the app
                              The app state is updated frequently over time
                              The logic to update that state may be complex
                              The app has a medium or large-sized codebase, and might be worked on by many people
               
               Immutablity & Mutabaility:    
               Store:    The current Redux application state lives in an object called the store .
               
                         The store is created by passing in a reducer, and has a method called getState that returns the current state value.
               
               the actions that represent the facts about “what happened” and the reducers that update the state according to those actions.

                         The Store is the object that brings them together. The store has the following responsibilities:

                         Holds application state;
                         Allows access to state via getState();
                         Allows state to be updated via dispatch(action);
                         Registers listeners via subscribe(listener);
                         Handles unregistering of listeners via the function returned by subscribe(listener).
                         It's important to note that you'll only have a single store in a Redux application. When you want to split your data handling logic, you'll use reducer composition instead of many stores.


                         subscribe(listener):     https://redux.js.org/api/store#subscribelistener

               Actions:       Actions are payloads of information that send data from your application to your store. They are the only source of information for the store. You send them to the store using store.dispatch().
               
                              Actions are plain JavaScript objects. Actions must have a type property that indicates the type of action being performed. Types should typically be defined as string constants. Once your app is large enough, you may want to move them into a separate module.
                              Other than type, the structure of an action object is really up to you.
                              {
                                type: SET_VISIBILITY_FILTER,
                                filter: SHOW_COMPLETED
                              }
                              or
                              {
                                type: SET_VISIBILITY_FILTER,
                                index: 5
                              }

                         An examnple of action object will look like {type: 'posts/postUpdated', payload: {id, title, content}}
                         
                         By default, the action creators generated by createSlice expect you to pass in one argument, and that value will be put into the action object as action.payload. So, we can pass an object containing those fields as the argument to the postUpdated action creator.


               
               Action Creators:     Action creators are exactly that—functions that create actions. It's easy to conflate the terms “action” and “action creator”, so do your best to use the proper term.

                                   In Redux, action creators simply return an action:
                                                       function addTodo(text) {
                                     return {
                                       type: ADD_TODO,
                                       text
                                     }
                                   }
                                   Action creators generated by createSlice 
               
                    Finally, we'll need to export the action creator function that createSlice generated for us, so that the UI can dispatch the new postUpdated action when the user saves the post.
               
                Dispatch: 
                              The Redux store has a method called dispatch. The only way to update the state is to call store.dispatch() and pass in an action object. The store will run its reducer function and save the new state value inside, and we can call getState() to retrieve the updated value:
               
               In order to dispatch actions from a component, we need access to the store's dispatch function. We get this by calling the useDispatch hook from React-Redux.
                    Any component that needs to read data from the Redux store can use the useSelector hook, and extract the specific pieces of data that it needs.
               
               Selectors:     Selectors are functions that know how to extract specific pieces of information from a store state value. As an application grows bigger, this can help avoid repeating logic as different parts of the app need to read the same data:
              
              
               Slice:
               Reducers:   Reducers specify how the application's state changes in response to actions sent to the store. Remember that actions only describe what happened, but don't describe how the application's state changes.
                         The reducer is a pure function that takes the previous state and an action, and returns the next state.
                         Eg:  (previousState, action) => nextState
                         
                         It's called a reducer because it's the type of function you would pass to Array.prototype.reduce(reducer, ?initialValue). It's very important that the reducer stays pure. Things you should never do inside a reducer:

                    Mutate its arguments;
                    Perform side effects like API calls and routing transitions;
                    Call non-pure functions, e.g. Date.now() or Math.random().

                         This is a reducer, a pure function with (state, action) => state signature. It describes how an action transforms the state into the next state.    
                                        
                    Create a Redux store holding the state of your app. Use Its API is { subscribe, dispatch, getState }.
                    
                    Redux Dataflow: With components dispatching actions, reducers processing actions and returning new state, and components reading the new state and rerendering the UI
                    Actions, Reducers (actually updates the data in store) & dispatch are key in creating & updting the store.
                    
                    React components can read data from the Redux store using the useSelector hook from the React-Redux library. The "selector functions" that you write will be called with the entire Redux state object as a parameter, and should return the specific data that this component needs from the store.
                    
                    We also know that the reducer is responsible for determing how the state should actually be updated when an action is dispatched.
                    
                    Example:
                              function counter(state = 0, action) {
                                switch (action.type) {
                                  case 'INCREMENT':
                                    return state + 1
                                  case 'DECREMENT':
                                    return state - 1
                                  default:
                                    return state
                                }
                              }

                              // Create a Redux store holding the state of your app.
                              // Its API is { subscribe, dispatch, getState }.
                              let store = createStore(counter)

                              // You can use subscribe() to update the UI in response to state changes.
                              // Normally you'd use a view binding library (e.g. React Redux) rather than subscribe() directly.
                              // However it can also be handy to persist the current state in the localStorage.

                              store.subscribe(() => console.log(store.getState()))

                              // The only way to mutate the internal state is to dispatch an action.
                              // The actions can be serialized, logged or stored and later replayed.
                              store.dispatch({ type: 'INCREMENT' })

                    Reducers must always follow some specific rules:

                         They should only calculate the new state value based on the state and action arguments
                         They are not allowed to modify the existing state. Instead, they must make immutable updates, by copying the existing state and making changes to the copied values.
                         They must not do any asynchronous logic, calculate random values, or cause other "side effects"
               
               Redux Application Data Flow: Earlier, we talked about "one-way data flow", which describes this sequence of steps to update the app:

                         State describes the condition of the app at a specific point in time
                         The UI is rendered based on that state
                         When something happens (such as a user clicking a button), the state is updated based on what occurred
                         The UI re-renders based on the new state
                         For Redux specifically, we can break these steps into more detail:

          Initial setup:
                         A Redux store is created using a root reducer function
                         The store calls the root reducer once, and saves the return value as its initial state
                         When the UI is first rendered, UI components access the current state of the Redux store, and use that data to decide what to render. They also subscribe to any future store updates so they can know if the state has changed.
          Updates:
                         Something happens in the app, such as a user clicking a button
                         The app code dispatches an action to the Redux store, like dispatch({type: 'counter/increment'})
                         The store runs the reducer function again with the previous state and the current action, and saves the return value as the new state
                         The store notifies all parts of the UI that are subscribed that the store has been updated
                         Each UI component that needs data from the store checks to see if the parts of the state they need have changed.
                         Each component that sees its data has changed forces a re-render with the new data, so it can update what's shown on the screen.
          


  React Profiler (Frtom React 16.5): Collect tioming information to identify performance bottlenecks in react applications.
  
  
Time slicling & suspence features:


TransitionCOmponent:
React.FC:       Reacts functional components are simply JavaScript functions, but this doesn’t mean that they don’t follow any constraints. Specifically, and most importantly, functional components take an object of props, which we will need to type.
                Creating a functional component in TypeScript we first need to use the type React.FC, which is based on the FunctionComponent interface:
  
                

Axios:  Axios is among the most popular promise based HTTP clients for both browsers and Node.js.
        Axios provides support for request and response interceptors, transformers and auto-conversion to JSON. It’s also protecting you by default against cross-site request forgery (XSRF).
        Axios is promise-based and thus we can take advantage of async and await for more readable asynchronous code. We can also intercept and cancel requests, and there’s built-in client side protection against cross site request forgery. But the best part about Axios? The easy to use API!
      
      
      https://designrevision.com/react-axios/
        
Fetch API:  Fetch is a new-ish, promise-based API that lets us do Ajax requests without all the fuss associated with XMLHttpRequest. As you’ll see in this post, Fetch is very easy to use and work with and greatly simplifies fetching resources from an API. Plus, it’s now supported in all modern browsers, so using Fetch is really a no-brainer.
            Let’s demonstrate a simple GET request by going and GET ourselves some dummy data from the JSONPlaceholder API:
            
            
            
    https://www.edureka.co/blog/interview-questions/react-interview-questions/
    https://medium.com/@vigowebs/frequently-asked-react-js-interview-questions-and-answers-36f3dd99f486
    https://www.fullstack.cafe/blog/react-js-interview-questions
    
            
            fetch('https://jsonplaceholder.typicode.com/users')
              .then(res => res.json())
              .then(res => res.map(user => user.username))
              .then(userNames => console.log(userNames));


          https://alligator.io/js/fetch-api/

Axios vs Fetch:

************************************************************

https://medium.com/the-andela-way/understanding-the-fundamentals-of-routing-in-react-b29f806b157e


What is SPA (Single page application) ? How does tyhat work and is React an SPA ?
Responsive Design. ?

Life Cycle:

  https://reactjs.org/docs/state-and-lifecycle.html
  
  https://programmingwithmosh.com/javascript/react-lifecycle-methods/
  
  https://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75
  
PropTypes:
      
      https://reactjs.org/docs/typechecking-with-proptypes.html
      
      https://www.geeksforgeeks.org/reactjs-proptypes/
      
      https://blog.bitsrc.io/understanding-react-proptypes-type-checking-in-react-9648a62ce12e
    
      https://css-tricks.com/props-and-proptypes-in-react/
      
    
Exeption Handling:

      https://www.smashingmagazine.com/2020/06/react-error-handling-reporting-error-boundary-sentry/
      
      https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html
      
      
Async, Await

https://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75

https://levelup.gitconnected.com/usetypescript-a-complete-guide-to-react-hooks-and-typescript-db1858d1fb9c                     [React Hooks]

https://levelup.gitconnected.com/using-react-functional-components-with-hooks-in-typescript-6d61075edddc                       [React FC] 

https://levelup.gitconnected.com/a-guide-to-service-workers-in-react-js-82aec1d6a22d                                            [Service Workers]

Store:

    https://stackoverflow.com/questions/48356854/storing-data-in-react
    
    https://react-redux.js.org/using-react-redux/accessing-store?_sm_au_=iVVMDMqwk5FTLNtPscpQ8KHVVHCJF
    
    https://www.freecodecamp.org/news/where-do-i-belong-a-guide-to-saving-react-component-data-in-state-store-static-and-this-c49b335e2a00/
    
    https://www.robinwieruch.de/local-storage-react
    
    

Testing:
    https://testing-library.com/docs/dom-testing-library/cheatsheet
    
    https://testing-library.com/docs/react-testing-library/cheatsheet
    
    https://jestjs.io/docs/en/tutorial-react
    
Antd:

    https://ant.design/docs/spec/reaction

https://create-react-app.dev/docs/making-a-progressive-web-app/

Responsive App:

https://codeburst.io/how-to-build-fully-responsive-react-apps-with-nothing-but-inline-styles-and-javascript-242c091b6ba1

https://medium.com/@mustwin/responsive-react-9b56d63c4edc

https://www.npmjs.com/package/react-responsive




FAQs:

  https://reactjs.org/docs/hooks-reference.html                                           { Hooks }
  
  https://kentcdodds.com/blog/the-state-reducer-pattern-with-react-hooks            { Reducer pattern }

  https://www.edureka.co/blog/interview-questions/react-interview-questions/
  
  https://medium.com/@vigowebs/frequently-asked-react-js-interview-questions-and-answers-36f3dd99f486
  
  https://www.fullstack.cafe/blog/react-js-interview-questions
  
  https://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75
  
  https://medium.com/@theflyingmantis/async-await-react-promise-testing-a0d454b5461b { Async, Await & React promise }
  
  https://reactjs.org/docs/forms.html#controlled-components { Controlled Components }
  
  https://medium.com/javascript-in-plain-english/how-to-use-async-function-in-react-hook-useeffect-typescript-js-6204a788a435  { async & useEffect }
  
  https://www.robinwieruch.de/react-hooks-fetch-data { Data Fetch with React Hooks }
  
  https://medium.com/@miloshn/how-to-fetch-data-using-reacthooks-and-async-await-in-react-3ab137c63a2e { Data Fetch with React Hooks  using Async / Await }
  
  https://stackoverflow.com/questions/53146795/react-usereducer-async-data-fetch { React useReducer async data fetch }
  
  https://medium.com/javascript-in-plain-english/handling-api-calls-using-async-await-in-useeffect-hook-990fb4ae423 { Handling API calls with Async await with useEffect hook }
  
  https://stackoverflow.com/questions/53898810/executing-async-code-on-update-of-state-with-react-hooks
  
  https://dev.to/silvestricodes/asynchronous-flows-with-react-hooks-1g0m
  
  
  
  https://medium.com/@theflyingmantis/callbacks-vs-promises-and-basics-of-js-80d3d1515e81
  
  
  https://www.tiny.cloud/docs/integrations/react/  { Text editor for content, formatting & impage}




FAQ's:
=============


ES5 vs ES6
Classes vs Functions
Component vs PureComponent vs TransitionComponent
Java script & OOPS
Stateless Component vs Stateful Component
Render Prop vs HOC ?
React class components vs functional components
Controlled Components vs UnControlled Components
Component vs JSX
Java Script vs TypeScript
React with TypeScript & With out type script
React with out Hooks
React with out Redux
State sharing between components
Reusable Components
Reusable Hooks
Propgating data, prop, state from parent to child and child to parent
Pushing Notifictions
Profiling
Optimization with minifying
Debugging & tracing
Babel & Polifill
webpack
Subsriptions

https://smallpdf.com/shared#st=fb22d477-54f5-4659-bbf8-9e64e4178866&fn=Payslip_August_2020-merged.pdf&ct=1598876404884&tl=merge&rf=link



material-ui:
***************

https://codelabs.developers.google.com/codelabs/mdc-101-web#1

MDC Web uses a CSS preprocessor called Sass. If you're using a different CSS preprocessor (or none at all), that's OK! You can use Sass alongside your current preprocessor by installing the sass CLI or using a plugin (for example, sass-loader for Webpack, gulp-sass for Gulp, or grunt-sass for Grunt) in your build toolchain.

In order for our code to work in older browsers like IE 11, we use a transpiler called Babel to transpile MDC Web's ES2015 JavaScript syntax down to ES5 JavaScript syntax.

We'll be using webpack to bundle our files and to locally serve our site. The webpack configuration for this project has already been set up for you in the webpack.config.js file. For more details on how it was configured, see the Getting Started guide.

npm install material-components-web@^6.0.0


